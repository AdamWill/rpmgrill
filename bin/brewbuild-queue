#!/usr/bin/perl
#
# brewbuild-queue - put one or more jobs into the rpmgrill queue
#
# $Id$
#
package BrewBuild::Queue;

use strict;
use warnings;

(our $ME = $0) =~ s|.*/||;
our $VERSION = "0.01";

# For debugging, show data structures using DumpTree($var)
#use Data::TreeDumper; $Data::TreeDumper::Displayaddress = 0;

use DBI;
use File::Slurp         qw(read_dir);
use YAML::Syck;

###############################################################################
# BEGIN user-customizable section

# Subdirectory into which brewbuild-monitor writes job files, and
# in which we operate.
our $Jobs_Dir = 'jobs';

# END   user-customizable section
###############################################################################

###############################################################################
# BEGIN boilerplate args checking, usage messages

sub usage {
    print  <<"END_USAGE";
Usage: $ME [OPTIONS]

$ME is step 2 in the rpmgrill cycle:

     1) brewbuild-monitor listens to message bus, writes a file for
        each successful build
 **  2) we import that file into rpmgrill's database
     3) ...further steps...

We look in a directory called '$Jobs_Dir'. In that directory
are three further subdirectories with names of the form:

    queued/
    running/
    done/

We look in 'queued'. When we find a .yaml file, we move it
into 'running'. Then we read it, import into SQL, and finally
move it to 'done'. The file keeps the same name.

OPTIONS:

  -v, --verbose  show verbose progress indicators
  -n, --dry-run  don't actually import

  --help         display this message
  --man          display program man page
  --version      display program name and version
END_USAGE

    exit;
}

sub man {
    # Read the POD contents.  If it hasn't been filled in yet, abort.
    my $pod = do { local $/; <DATA>; };
    if ($pod =~ /=head1 \s+ NAME \s+ FIXME/xm) {
        warn "$ME: No man page available.  Please try $ME --help\n";
        exit;
    }

    # Use Pod::Man to convert our __DATA__ section to *roff
    eval { require Pod::Man }
        or die "$ME: Cannot generate man page; Pod::Man unavailable: $@\n";
    my $parser = Pod::Man->new(name => $ME, release => $VERSION, section => 1);

    # If called without output redirection, man-ify.
    my $out_fh;
    if (-t *STDOUT) {           ## no critic
        my $pager = $ENV{MANPAGER} || $ENV{PAGER} || 'less';
        open $out_fh, "| nroff -man | $pager";  ## no critic
    }
    else {
        open $out_fh, '>&', \*STDOUT;
    }

    # Read the POD contents, and have Pod::Man read from fake filehandle.
    # This requires 5.8.0.
    open my $pod_handle, '<', \$pod;
    $parser->parse_from_filehandle($pod_handle, $out_fh);
    exit;
}


# Command-line options.  Note that this operates directly on @ARGV !
our $debug   = 0;
our $force   = 0;
our $verbose = 0;
our $NOT     = '';              # print "blahing the blah$NOT\n" if $debug
sub handle_opts {
    use Getopt::Long;
    GetOptions(
        'debug!'     => \$debug,
        'dry-run|n!' => sub { $NOT = ' [NOT]' },
        'force'      => \$force,
        'verbose|v'  => \$verbose,

        help         => \&usage,
        man          => \&man,
        version      => sub { print "$ME version $VERSION\n"; exit 0 },
    ) or die "Try `$ME --help' for help\n";
}

# END   boilerplate args checking, usage messages
###############################################################################

############################## CODE BEGINS HERE ###############################

# The term is "modulino".
__PACKAGE__->main()                                     unless caller();

# Main code.
sub main {
    # Note that we operate directly on @ARGV, not on function parameters.
    # This is deliberate: it's because Getopt::Long only operates on @ARGV
    # and there's no clean way to make it use @_.
    handle_opts();                      # will set package globals

    # No command-line args
    die "$ME: Too many arguments; try $ME --help\n"                 if @ARGV;

    process_queue_dir();
}


#######################
#  process_queue_dir  #  Find all YAML files in a queue dir
#######################
sub process_queue_dir {
    my $queue_dir   = find_dir( 'queue' );
    my $running_dir = find_dir( 'running' );
    my $done_dir    = find_dir( 'done' );

    my $dbh = DBI->connect("DBI:mysql:rpmgrill:localhost", 'rpmgrill')
        or die;

    while (1) {
        # Look for .yaml files in the queue directory.
        my @yaml = sort grep { /\.yaml$/ } read_dir( $queue_dir )
            or do {
                # None found
                print "$ME: Nothing under $queue_dir; exiting\n" if $verbose;
                exit;
            };

        # At least one found. And that's all we care about: one.
        # On our next loop, we will reread the directory.
        my $yaml = $yaml[0];

        # Move into a holding pen before processing. This might fail
        # if we have two $ME processes running; we have no locking.
        rename "$queue_dir/$yaml" => "$running_dir/$yaml"
            or die "$ME: Cannot move $queue_dir/$yaml into $running_dir: $!\n";

        # Process the file: read it, write parts of it into SQL
        process_queue_file( "$running_dir/$yaml", $dbh );

        # Finished.
        rename "$running_dir/$yaml" => "$done_dir/$yaml"
            or die "$ME: Cannot move $running_dir/$yaml into $done_dir: $!\n";
    }
}


########################
#  process_queue_file  #  Import one YAML file into the rpmgrill DB
########################
sub process_queue_file {
    my $path = shift;
    my $dbh  = shift;

    # Read the YAML file
    my $info = YAML::Syck::LoadFile( $path )
        or die "$ME: Error reading $path as yaml...";
#    use Data::Dumper; print Dumper($info);

    #
    # Dup detection.
    #
    my $brew_build_id = $info->[1]{id}
        or die "$ME: No brew 'id' in $path\n";
    my @dup = $dbh->selectrow_array('SELECT * FROM runs WHERE brew_build_id=?',
                                  undef,
                                  $brew_build_id);
    if (@dup) {
        # FIXME: should we return failure, and/or move qfile into 'failed'?
        die "$ME: will not insert duplicate of $brew_build_id [$path]\n";
    }

    #
    # SQL normalization: owner and brew_tag are looked up
    # in separate tables, for space efficiency.
    #

    # Owner name
    my $owner_name = $info->[1]{owner_name}
        or die "$ME: No owner name in $path";
    my @owner_id = $dbh->selectrow_array("SELECT user_id FROM users WHERE user_name=?",
                                         undef,
                                         $owner_name);

    if (! @owner_id) {
        $dbh->do('INSERT INTO users (user_name) VALUES (?)', undef, $owner_name);
        @owner_id = ($dbh->{mysql_insertid});

    }

    # Brew tag. FIXME: is 'dest_tag' the one we want, or 'build_tag' ?
    my $brew_tag_name = $info->[2]{dest_tag_name}
        or die "$ME: No brew dest_tag_name in $path";
    my @tag_id = $dbh->selectrow_array("SELECT brew_tag_id FROM brew_tags WHERE brew_tag_name=?",
                                         undef,
                                         $brew_tag_name);

    if (! @tag_id) {
        $dbh->do('INSERT INTO brew_tags (brew_tag_name) VALUES (?)', undef, $brew_tag_name);
        @tag_id = ($dbh->{mysql_insertid});
    }

    # Shove into SQL
    my $sth = $dbh->prepare( <<'END_SQL' );
INSERT INTO runs (package_name, package_version, package_release, brew_build_id, brew_tag_id, owner_id, state)
          VALUES (           ?,               ?,               ?,             ?,           ?,        ?, 'queued')
END_SQL
    # FIXME...

    $sth->execute(
        $info->[1]{name},
        $info->[1]{version},
        $info->[1]{release},
        $brew_build_id,
        $tag_id[0],
        $owner_id[0],
    );
}


##############
#  find_dir  #  Find a subdirectory with the given name
##############
#
# ...needed because the tree structure looks like:
#
#    jobs/
#    ├── 01-queued/
#    ├── 02-running/
#    └── 03-done/
#
# (for human readability). We don't want to hardcode in the numbers.
#
sub find_dir {
    my $what = shift;                   # in: 'queue', 'running', etc

    my @dir = grep { /$what/ } read_dir( $Jobs_Dir )
        or die "$ME: Did not find a *$what* directory under $Jobs_Dir";
    @dir == 1
        or die "$ME: Ambiguous $what dirs under $Jobs_Dir: @dir";

    return "$Jobs_Dir/$dir[0]";
}

1;

__DATA__

###############################################################################
#
# Documentation
#

=head1	NAME

FIXME - description of what this script does

=head1	SYNOPSIS

FIXME [B<--foo>]  [B<--bar>]  [B<--verbose>] ARG1 [ARG2...] FIXME

FIXME  B<--help>  |  B<--version> | B<--man>

=head1	DESCRIPTION

B<FIXME> grobbles the frobniz on alternate Tuesdays, except where
prohibited by law.

=head1	OPTIONS

=over 4

=item B<--foo>

FIXME

=item B<--verbose>

Show progress messages.

=item B<--help>

Emit usage hints.

=item B<--version>

Display program version.

=item B<--man>

Display this man page.

=back


=head1	DIAGNOSTICS

FIXME

=head1	ENVIRONMENT

FIXME

=head1	FILES

FIXME

=head1	RESTRICTIONS

FIXME

=head1	SEE ALSO

FIXME

e.g. L<Foo::Bar|Foo::Bar>

=head1	AUTHOR

Your Name <ed@edsantiago.com>

Please report bugs or suggestions to <ed@edsantiago.com>

=cut
